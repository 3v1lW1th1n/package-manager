#! /usr/bin/env python

from __future__ import print_function
import os
import sys
import argparse
import logging
import subprocess
import StringIO

if sys.version_info[0] < 3:
    import ConfigParser as configparser
else:
    import configparser

import bropkg


def print_error(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def config_items(config, section):
    # Same as config.items(section), but exclude default keys.
    defaults = {key for key, _ in config.items('DEFAULT')}
    items = config.items(section)
    return [(key, value) for (key, value) in items if key not in defaults]


def create_manager(config_path):

    def require_config_section(section):
        sections = config.sections()

        if section in sections:
            return

        print_error(
            'error: config file "{}" is missing a "{}" section'.format(
                config_path, section))
        sys.exit(1)

    def require_config_option(section, option):
        if config.has_option(section, option):
            return

        print_error(str.format('error: config file "{}" is missing option '
                               '"{}" in section "{}"',
                               config_path, option, section))

        sys.exit(1)

    client_path = os.path.abspath(__file__)
    client_dir = os.path.dirname(client_path)

    if not config_path:
        config_path = os.environ.get('BRO_PKG_CONFIG_PATH')

    if not config_path:
        config_path = os.path.join(client_dir, 'bro-pkg.config')

    if not os.path.isfile(config_path):
        print_error('error: invalid config file "{}"'.format(config_path))
        sys.exit(1)

    defaults = {'command_line_client_dir': client_dir}
    config = configparser.SafeConfigParser(defaults=defaults)
    config.read(config_path)
    require_config_section('sources')
    require_config_section('paths')
    require_config_option('sources', 'default')
    require_config_option('paths', 'state')

    if not config.has_option('paths', 'bro_exe') or not config.get('paths',
                                                                   'bro_exe'):
        bro_exe = bropkg.util.find_program('bro')
        config.set('paths', 'bro_exe', bro_exe if bro_exe else '')

    state_path = config.get('paths', 'state')
    manager = bropkg.Manager(state_path=state_path)

    for key, value in config_items(config, 'sources'):
        res = manager.add_source(name=key, git_url=value)

        if res == bropkg.Error.INVALID_SOURCE:
            print_error(
                'error: source "{}" in {} is not a valid git repo'.format(
                    key, config_path))
            sys.exit(1)
        elif res == bropkg.Error.CONFLICTING_SOURCE:
            print_error(
                'error: config file {} has two sources named "{}"'.format(
                    config_path, key))
            sys.exit(1)

    return manager, config


def cmd_install(manager, args, config):
    for pkg in args.package:
        res = manager.install(pkg)

        if res == bropkg.Error.NONE:
            print('installed "{}"'.format(pkg))

            res = manager.load(pkg)

            if res == bropkg.Error.NONE:
                print('loaded "{}"'.format(pkg))
            else:
                print('failed to load "{}"'.format(pkg))

        elif res == bropkg.Error.INVALID_PACKAGE:
            print_error('failed to install "{}": invalid package'.format(pkg))
        elif res == bropkg.Error.AMBIGUOUS_PACKAGE:
            print_error(
                'failed to install "{}": '.format(pkg) +
                'ambiguous package name, choose more specific name from:')
            matches = manager.match_source_packages(pkg)

            for match in matches:
                print_error('\t{}'.format(match))
        elif res == bropkg.Error.CONFLICTING_PACKAGE:
            print_error(
                'failed to install "{}": '.format(pkg) +
                'package name conflicts with an already installed package: '
                '"{}"'.format(manager.match_installed_packages(pkg)))
        elif res == bropkg.Error.INVALID_PACKAGE_METADATA:
            print_error('failed to install "{}": invalid metadata'.format(pkg))
        else:
            print_error('unknown error installing "{}"'.format(pkg))


def cmd_remove(manager, args, config):
    for pkg in args.package:
        res = manager.remove(pkg)

        if res == bropkg.Error.NONE:
            print('removed "{}"'.format(pkg))
        elif res == bropkg.Error.INVALID_PACKAGE:
            print_error('failed to remove "{}": invalid package'.format(pkg))
        else:
            print_error('unknown error installing "{}"'.format(pkg))


def cmd_refresh(manager, args, config):
    # @todo: `git pull` in client repo
    manager.refresh()


def cmd_upgrade(manager, args, config):
    # @todo
    print(args)


def cmd_load(manager, args, config):
    for pkg in args.package:
        res = manager.load(pkg)

        if res == bropkg.Error.NONE:
            print('loaded "{}"'.format(pkg))
        elif res == bropkg.Error.INVALID_PACKAGE:
            print_error('failed to load "{}": invalid package'.format(pkg))
        else:
            print_error('unknown error loading "{}"'.format(pkg))


def cmd_unload(manager, args, config):
    for pkg in args.package:
        res = manager.unload(pkg)

        if res == bropkg.Error.NONE:
            print('unloaded "{}"'.format(pkg))
        elif res == bropkg.Error.INVALID_PACKAGE:
            print_error('failed to unload "{}": invalid package'.format(pkg))
        else:
            print_error('unknown error unloading "{}"'.format(pkg))


def cmd_pin(manager, args, config):
    # @todo
    print(args)


def cmd_unpin(manager, args, config):
    # @todo
    print(args)


def all_packages(manager):
    source_pkgs = manager.source_packages()
    installed_pkgs = manager.installed_packages()
    pkg_dict = {pkg.git_url: (pkg, True) for pkg in installed_pkgs}

    for pkg in source_pkgs:
        if pkg.git_url not in pkg_dict:
            pkg_dict[pkg.git_url] = (pkg, False)

    return [value for _, value in pkg_dict.items()]


def cmd_list(manager, args, config):
    # @todo: improve formatting
    if args.category == 'all':
        for pkg_tuple in sorted(all_packages(manager)):
            pkg = pkg_tuple[0]
            installed = pkg_tuple[1]

            if installed:
                print('{} (installed)'.format(pkg))
            else:
                print('{}'.format(pkg))

    elif args.category == 'installed':
        installed_pkgs = manager.installed_packages()

        for pkg in sorted(installed_pkgs):
            print(pkg)

    elif args.category == 'not_installed':
        for pkg_tuple in sorted(all_packages(manager)):
            pkg = pkg_tuple[0]
            installed = pkg_tuple[1]

            if not installed:
                print('{}'.format(pkg))

    elif args.category == 'loaded':
        loaded_pkgs = manager.loaded_packages()

        for pkg in sorted(loaded_pkgs):
            print(pkg)

    elif args.category == 'unloaded':
        installed_pkgs = manager.installed_packages()
        loaded_pkgs = {pkg.name: pkg for pkg in manager.loaded_packages()}

        for pkg in sorted(installed_pkgs):
            if pkg.name not in loaded_pkgs:
                print(pkg)

    elif args.category == 'outdated':
        # @todo
        raise NotImplementedError

    else:
        raise NotImplementedError


def cmd_search(manager, args, config):
    # @todo
    print(args)


def cmd_info(manager, args, config):
    # @todo
    print(args)


def cmd_test(manager, args, config):
    # @todo
    print(args)


def cmd_config(manager, args, config):
    if args.config_param == 'all':
        out = StringIO.StringIO()
        config.write(out)
        print(out.getvalue())
        out.close()
    elif args.config_param == 'sources':
        for key, value in config_items(config, 'sources'):
            print('{} = {}'.format(key, value))
    elif args.config_param == 'state':
        print(config.get('paths', 'state'))
    elif args.config_param == 'bro_exe':
        print(config.get('paths', 'bro_exe'))
    else:
        raise NotImplementedError


def cmd_env(manager, args, config):
    bro_exe = config.get('paths', 'bro_exe')

    if bro_exe:
        # Parse the output of 'bro --help' to determine starting values for
        # BROPATH and BRO_PLUGIN_PATH.  e.g. for users that don't set those
        # in their environment, bro has builtin paths to its installation
        # directory that it uses and this is an easy way to get things working
        # in that situation.  Parsing --help output isn't great, but we can
        # check 'bro --version' here if the output format ever changes or
        # just formalize some 'bro --config <param>' later to retrieve these
        # values in a more well-defined manner.
        cmd = subprocess.Popen([bro_exe, '--help'], stdout=subprocess.PIPE,
                               stderr=subprocess.STDOUT)

        for line in cmd.stdout:
            parts = line.split()

            if not parts:
                continue

            if parts[0] == "$BROPATH":
                bropaths = {p for p in parts[-1][1:-1].split(':')}
            elif parts[0] == "$BRO_PLUGIN_PATH":
                pluginpaths = {p for p in parts[-1][1:-1].split(':')}

    else:
        # Start with whatever values the current environment uses and add
        # the package manager paths to them.
        bropath = os.environ.get('BROPATH')
        pluginpath = os.environ.get('BRO_PLUGIN_PATH')
        bropaths = {p for p in bropath.split(':')} if bropath else set()
        pluginpaths = {p for p in pluginpath.split(
            ':')} if pluginpath else set()

    bropaths = bropaths.union(manager.bropaths())
    pluginpaths = pluginpaths.union(manager.pluginpaths())

    if os.environ['SHELL'].endswith('csh'):
        print('setenv BROPATH {}'.format(':'.join(bropaths)))
        print('setenv BRO_PLUGIN_PATH {}'.format(':'.join(pluginpaths)))
    else:
        print('export BROPATH={}'.format(':'.join(bropaths)))
        print('export BRO_PLUGIN_PATH={}'.format(':'.join(pluginpaths)))


def main():
    top_parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='Manage Bro packages.',
        epilog='Environment Variables:\n\n'
        '    BRO_PKG_CONFIG_PATH\t'
        'Same as --config option, but takes precedence.'
    )
    top_parser.add_argument('--version', action='version',
                            version='%(prog)s ' + bropkg.__version__)
    top_parser.add_argument('--config',
                            help='Path to Bro Package Manager config file.')
    top_parser.add_argument('--verbose', '-v', action='count', default=0,
                            help='May be used multiple times (e.g. -vvv) for'
                            ' increased program output (e.g. for debugging)')

    command_parser = top_parser.add_subparsers(
        title='commands', dest='command',
        help='See `%(prog)s <command> -h` for per-command usage info.')

    # install
    sub_parser = command_parser.add_parser(
        'install',
        help='Install a package.', description='Install a package.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_install)
    sub_parser.add_argument(
        'package', nargs='+', help='Name(s) of package(s) to install.')
    sub_parser.add_argument(
        '--version', default='master',
        help='The version of the package to install.')

    # remove
    sub_parser = command_parser.add_parser(
        'remove', help='Remove a package.',
        description='Remove a previously installed package',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_remove)
    sub_parser.add_argument(
        'package', nargs='+', help='Name(s) of package(s) to remove.')

    # refresh
    sub_parser = command_parser.add_parser(
        'refresh',
        help='Update client and sources.',
        description='Retrieve latest client version and aggregated package'
        ' metadata from package source repositories.  This does not upgrade'
        ' installed packages (see the "upgrade" command for that).',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_refresh)

    # upgrade
    sub_parser = command_parser.add_parser(
        'upgrade',
        help='Upgrade installed packages to latest versions.',
        description='Uprades package(s) to latest available version.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_upgrade)
    sub_parser.add_argument(
        'package', nargs='*', default=[],
        help='Name(s) of package(s) to upgrade (or blank to upgrade all).')

    # load
    sub_parser = command_parser.add_parser(
        'load',
        help='Register packages to be be auto-loaded by Bro.',
        description='The Bro Package Manager keeps track of all packages that'
        ' are marked as "loaded" and supplies necessary config files to make it'
        ' easy/convenient for Bro to load all such packages at once.  This'
        ' command adds a set of packages to the "loaded packages" list.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_load)
    sub_parser.add_argument(
        'package', nargs='+', default=[],
        help='Name(s) of package(s) to load.')

    # unload
    sub_parser = command_parser.add_parser(
        'unload',
        help='Register packages to be be auto-loaded by Bro.',
        description='The Bro Package Manager keeps track of all packages that'
        ' are marked as "loaded" and supplies necessary config files to make it'
        ' easy/convenient for Bro to load all such packages at once.  This'
        ' command removes a set of packages from the "loaded packages" list.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_unload)
    sub_parser.add_argument(
        'package', nargs='+', default=[],
        help='Name(s) of package(s) to unload.')

    # pin
    sub_parser = command_parser.add_parser(
        'pin',
        help='Prevent packages from being automatically upgraded.',
        description='Packages that are pinned will be ignored by "upgrade."',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_pin)
    sub_parser.add_argument(
        'package', nargs='+', default=[],
        help='Name(s) of package(s) to pin.')

    # unpin
    sub_parser = command_parser.add_parser(
        'unpin',
        help='Allows packages to be automatically upgraded.',
        description='Packages that are not pinned are automatically upgraded'
        ' by "upgrade."',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_unpin)
    sub_parser.add_argument(
        'package', nargs='+', default=[],
        help='Name(s) of package(s) to unpin.')

    # list
    sub_parser = command_parser.add_parser(
        'list',
        help='Lists packages.',
        description='Packages that are not pinned are automatically upgraded'
        ' by "upgrade."',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_list)
    sub_parser.add_argument('category', nargs='?', default='installed',
                            choices=['all', 'installed', 'not_installed',
                                     'loaded', 'unloaded', 'outdated'],
                            help='Package category used to filter listing.')

    # search
    sub_parser = command_parser.add_parser(
        'search',
        help='Search packages for matching names.',
        description='Perform a substring search on package names.'
        ' Surround search text with slashes to indicate it is a regular'
        ' expression (e.g. "/text/").',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_search)
    sub_parser.add_argument('search_text',
                            help='Text to match against package names.')

    # info
    sub_parser = command_parser.add_parser(
        'info',
        help='Display package information.',
        description='Shows more detailed information for given packages.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_info)
    sub_parser.add_argument(
        'package', nargs='+', default=[],
        help='Name(s) of package(s) to query.')

    # test
    sub_parser = command_parser.add_parser(
        'test',
        help='Run unit tests for packages.',
        description='Runs unit tests for packages.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_test)
    sub_parser.add_argument(
        'package', nargs='+', default=[],
        help='Name(s) of package(s) to test.')

    # config
    sub_parser = command_parser.add_parser(
        'config',
        help='Show Bro Package Manager configuration info.',
        description='Show Bro Package Manager configuration info.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_config)
    sub_parser.add_argument(
        'config_param', nargs='?', default='all',
        choices=['all', 'sources', 'state', 'bro_exe'],
        help='Name of the config parameter to output.')

    # env
    sub_parser = command_parser.add_parser(
        'env',
        help='Show environment variables needed for Bro to be able to use '
             'packages installed by the Bro Package Manager.',
        description='Show Bro Package Manager environment info.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_env)

    args = top_parser.parse_args()

    if args.verbose > 0:
        formatter = logging.Formatter(
            '%(asctime)s %(levelname)-8s %(message)s', '%Y-%m-%d %H:%M:%S')
        handler = logging.StreamHandler()
        handler.setFormatter(formatter)

        if args.verbose == 1:
            bropkg.LOG.setLevel(logging.WARNING)
        elif args.verbose == 2:
            bropkg.LOG.setLevel(logging.INFO)
        elif args.verbose == 3:
            bropkg.LOG.setLevel(logging.DEBUG)

        bropkg.LOG.addHandler(handler)

    manager, config = create_manager(args.config)

    args.run_cmd(manager, args, config)


if __name__ == '__main__':
    main()
    sys.exit(0)
