#! /usr/bin/env python

from __future__ import print_function
import os
import sys
import argparse
import logging

if sys.version_info[0] < 3:
    import ConfigParser as configparser
else:
    import configparser

import bropkg


def print_error(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def config_items(config, section):
    # Same as config.items(section), but exclude default keys.
    defaults = {key for key, _ in config.items('DEFAULT')}
    items = config.items(section)
    return [(key, value) for (key, value) in items if key not in defaults]


def is_exe(path):
    return os.path.isfile(path) and os.access(path, os.X_OK)


def find_program(prog_name):
    path, _ = os.path.split(prog_name)

    if path:
        return prog_name if is_exe(prog_name) else ''

    for path in os.environ["PATH"].split(os.pathsep):
        path = os.path.join(path.strip('"'), prog_name)

        if is_exe(path):
            return path

    return ''


def create_manager(config_path):

    def require_config_section(section):
        sections = config.sections()

        if section in sections:
            return

        print_error(
            'error: config file "{}" is missing a "{}" section'.format(
                config_path, section))
        sys.exit(1)

    def require_config_option(section, option):
        if config.has_option(section, option):
            return

        print_error(str.format('error: config file "{}" is missing option '
                               '"{}" in section "{}"',
                               config_path, option, section))

        sys.exit(1)

    client_path = os.path.abspath(__file__)
    client_dir = os.path.dirname(client_path)
    statedir = os.path.join(os.path.expanduser('~'), '.bro-pkg')

    if not config_path:
        config_path = os.environ.get('BRO_PKG_CONFIG_FILE')

    if not config_path:
        config_path = os.path.join(statedir, 'config')

        if not os.path.isfile(config_path):
            # @todo: if installed, use the installed location instead
            config_path = os.path.join(client_dir, 'bro-pkg.config')

    if not os.path.isfile(config_path):
        print_error('error: invalid config file "{}"'.format(config_path))
        sys.exit(1)

    config = configparser.SafeConfigParser()
    config.read(config_path)
    require_config_section('sources')
    require_config_option('sources', 'default')

    scriptdir = os.path.join(statedir, 'scriptdir')
    plugindir = os.path.join(statedir, 'plugindir')
    bro_dist = ''
    bro_exe = find_program('bro')

    if config.has_section('paths'):
        def config_option_set(config, section, option):
            return config.has_option(section, option) and config.get(section,
                                                                     option)

        def get_option(config, section, option, default):
            if config_option_set(config, section, option):
                return config.get(section, option)

            return default

        statedir = get_option(config, 'paths', 'statedir', statedir)
        scriptdir = get_option(config, 'paths', 'scriptdir', scriptdir)
        plugindir = get_option(config, 'paths', 'plugindir', plugindir)
        bro_dist = get_option(config, 'paths', 'bro_dist', bro_dist)
        bro_exe = get_option(config, 'paths', 'bro_exe', bro_exe)

    else:
        config.add_section('paths')

    config.set('paths', 'statedir', statedir)
    config.set('paths', 'scriptdir', scriptdir)
    config.set('paths', 'plugindir', plugindir)
    config.set('paths', 'bro_exe', bro_exe)
    config.set('paths', 'bro_dist', bro_dist)

    manager = bropkg.Manager(statedir=statedir, scriptdir=scriptdir,
                             plugindir=plugindir, bro_dist=bro_dist)

    for key, value in config_items(config, 'sources'):
        if not manager.add_source(name=key, git_url=value):
            print_error(
                'error: invalid source repo "{}" in {} '.format(key,
                                                                config_path))
            sys.exit(1)

    return manager, config


def cmd_install(manager, args, config):
    if args.version and len(args.package) > 1:
        print_error(
            'error: "install --version" may only be used for a single package')
        sys.exit(1)

    for name in args.package:
        error = manager.install(name, args.version)

        if error:
            print_error('failed installing "{}": {}'.format(name, error))
            continue

        print('installed "{}"'.format(name))

        if manager.load(name):
            print('loaded "{}"'.format(name))
        else:
            print('failed to load "{}"'.format(name))


def cmd_remove(manager, args, config):
    for name in args.package:
        if manager.remove(name):
            print('removed "{}"'.format(name))
        else:
            print('failed removing "{}": no such package installed'.format(name))


def outdated(manager):
    return [ipkg.package.qualified_name()
            for ipkg in manager.installed_packages()
            if ipkg.status.is_outdated]


def cmd_refresh(manager, args, config):
    src_pkgs_before = {i.qualified_name() for i in manager.source_packages()}
    outdated_before = {i for i in outdated(manager)}
    manager.refresh()
    src_pkgs_after = {i.qualified_name() for i in manager.source_packages()}
    outdated_after = {i for i in outdated(manager)}

    if src_pkgs_before == src_pkgs_after:
        print('refreshed source packages: no changes')
    else:
        print('source package changes:')
        diff = src_pkgs_before.symmetric_difference(src_pkgs_after)

        for name in diff:
            change = 'added' if name in src_pkgs_after else 'removed'
            print('\t{} {}'.format(change, name))

    if outdated_before == outdated_after:
        print('refreshed installed packages: no new outdated packages')
    else:
        print('installed packages are outdated:')
        diff = outdated_before.symmetric_difference(outdated_after)

        for name in diff:
            print('\t{}'.format(name))


def cmd_upgrade(manager, args, config):
    if args.package:
        pkg_list = args.package
    else:
        pkg_list = outdated(manager)

    for name in pkg_list:
        res = manager.upgrade(name)

        if res:
            print('failed upgrading "{}": {}'.format(name, res))
        else:
            ipkg = manager.find_installed_package(name)
            print('upgraded "{}" ({})'.format(
                name, ipkg.status.current_version))


def cmd_load(manager, args, config):
    for name in args.package:
        if manager.load(name):
            print('loaded "{}"'.format(name))
        else:
            print_error(
                'failed loading "{}": no such package installed'.format(name))


def cmd_unload(manager, args, config):
    for name in args.package:
        if manager.unload(name):
            print('unloaded "{}"'.format(name))
        else:
            print_error(
                'failed unloading "{}": no such package installed'.format(name))


def cmd_pin(manager, args, config):
    for name in args.package:
        ipkg = manager.pin(name)

        if ipkg:
            print('pinned "{}" at version: {} ({})'.format(
                name, ipkg.status.current_version, ipkg.status.current_hash))
        else:
            print_error(
                'failed pinning "{}": no such package installed'.format(name))


def cmd_unpin(manager, args, config):
    for name in args.package:
        ipkg = manager.unpin(name)

        if ipkg:
            print('unpinned "{}" from version: {} ({})'.format(
                name, ipkg.status.current_version, ipkg.status.current_hash))
        else:
            print_error(
                'failed unpinning "{}": no such package installed'.format(name))


def cmd_list(manager, args, config):
    if args.category == 'all':
        for pkg in sorted(manager.source_packages()):
            ipkg = manager.find_installed_package(pkg.name)
            pkg_qn = pkg.qualified_name()
            output_fmt = '{} (installed)' if ipkg else '{}'
            print(output_fmt.format(pkg_qn))

    elif args.category == 'installed':
        installed_pkgs = [
            ipkg.package for ipkg in manager.installed_packages()]

        for pkg in sorted(installed_pkgs):
            print(pkg.qualified_name())

    elif args.category == 'not_installed':
        for pkg in sorted(manager.source_packages()):
            ipkg = manager.find_installed_package(pkg.name)

            if not ipkg:
                print(pkg.qualified_name())

    elif args.category == 'loaded':
        loaded_pkgs = [ipkg.package for ipkg in manager.loaded_packages()]

        for pkg in sorted(loaded_pkgs):
            print(pkg.qualified_name())

    elif args.category == 'unloaded':
        for ipkg in sorted(manager.installed_packages()):
            if not ipkg.status.is_loaded:
                print(ipkg.package.qualified_name())

    elif args.category == 'outdated':
        for ipkg in sorted(manager.installed_packages()):
            if ipkg.status.is_outdated:
                print(ipkg.package.qualified_name())

    else:
        raise NotImplementedError


def cmd_search(manager, args, config):
    # @todo: search metadata topics/tags
    src_pkgs = manager.source_packages()

    if args.search_text[0] == '/' and args.search_text[-1] == '/':
        import re

        try:
            regex = re.compile(args.search_text[1:-1])
        except re.error as error:
            print('invalid regex: {}'.format(error))
            sys.exit(1)
        else:
            matches = [pkg for pkg in src_pkgs if regex.search(
                pkg.module_path())]
    else:
        matches = [
            pkg for pkg in src_pkgs if args.search_text in pkg.module_path()]

    if matches:
        for match in matches:
            print(match.qualified_name())
    else:
        print("no matches")


def cmd_info(manager, args, config):
    for name in args.package:
        info = manager.info(name)
        print('"{}" info:'.format(name))

        if info.invalid_reason:
            print('\tinvalid package: {}'.format(info.invalid_reason))
            continue

        pkg = info.package
        print('\tgit URL: {}'.format(pkg.git_url))
        print('\tversions: {}'.format(pkg.versions))

        if info.status:
            print('\tinstall status:')

            for key, value in info.status.__dict__.items():
                print('\t\t{} = {}'.format(key, value))

        print('\tlatest metadata:')

        for key, value in pkg.metadata.items():
            print('\t\t{} = {}'.format(key, value))


def cmd_config(manager, args, config):
    if args.config_param == 'all':
        if sys.version_info[0] < 3:
            from StringIO import StringIO
        else:
            from io import StringIO

        out = StringIO()
        config.write(out)
        print(out.getvalue())
        out.close()
    elif args.config_param == 'sources':
        for key, value in config_items(config, 'sources'):
            print('{} = {}'.format(key, value))
    else:
        print(config.get('paths', args.config_param))


def cmd_env(manager, args, config):
    import subprocess
    bro_exe = config.get('paths', 'bro_exe')

    if bro_exe:
        # Parse the output of 'bro --help' to determine starting values for
        # BROPATH and BRO_PLUGIN_PATH.  e.g. for users that don't set those
        # in their environment, bro has builtin paths to its installation
        # directory that it uses and this is an easy way to get things working
        # in that situation.  Parsing --help output isn't great, but we can
        # check 'bro --version' here if the output format ever changes or
        # just formalize some 'bro --config <param>' later to retrieve these
        # values in a more well-defined manner.
        cmd = subprocess.Popen([bro_exe, '--help'], stdout=subprocess.PIPE,
                               stderr=subprocess.STDOUT, bufsize=1)

        for line in cmd.stdout:
            parts = line.decode().split()

            if not parts:
                continue

            if parts[0] == "$BROPATH":
                bropaths = [p for p in parts[-1][1:-1].split(':')]
            elif parts[0] == "$BRO_PLUGIN_PATH":
                pluginpaths = [p for p in parts[-1][1:-1].split(':')]

    else:
        # Start with whatever values the current environment uses and add
        # the package manager paths to them.
        bropath = os.environ.get('BROPATH')
        pluginpath = os.environ.get('BRO_PLUGIN_PATH')
        bropaths = [p for p in bropath.split(':')] if bropath else []
        pluginpaths = [p for p in pluginpath.split(':')] if pluginpath else []

    bropaths.append(manager.bropath())
    pluginpaths.append(manager.bro_plugin_path())

    if os.environ['SHELL'].endswith('csh'):
        print('setenv BROPATH {}'.format(':'.join(bropaths)))
        print('setenv BRO_PLUGIN_PATH {}'.format(':'.join(pluginpaths)))
    else:
        print('export BROPATH={}'.format(':'.join(bropaths)))
        print('export BRO_PLUGIN_PATH={}'.format(':'.join(pluginpaths)))


def argparser():
    pkg_name_help = 'The name(s) of package(s) to operate on.  The package' \
                    ' may be named in several ways.  If the package is part' \
                    ' of a package source, it may be referred to by the' \
                    ' base name of the package (last component of git URL)' \
                    ' or the submodule path within the package source.' \
                    ' If two packages in different package sources' \
                    ' have conflicting submodule paths, then the package' \
                    ' name may be prepended to the submodule path to resolve' \
                    ' the ambiguity. A full git URL may also be used to refer' \
                    ' to a package that does not belong to a source. E.g. for' \
                    ' a packge in a source named "default" at submodule path' \
                    ' "alice/foo", the following names work: "foo",' \
                    ' "alice/foo", "default/alice/foo".'

    top_parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='A command-line package manager for Bro.',
        epilog='Environment Variables:\n\n'
        '    BRO_PKG_CONFIG_FILE\t'
        'Same as --configfile option, but has less precedence.'
    )
    top_parser.add_argument('--version', action='version',
                            version='%(prog)s ' + bropkg.__version__)
    top_parser.add_argument('--configfile',
                            help='Path to Bro Package Manager config file.')
    top_parser.add_argument('--verbose', '-v', action='count', default=0,
                            help='May be used multiple times (e.g. -vvv) for'
                            ' increased program output (e.g. for debugging)')

    command_parser = top_parser.add_subparsers(
        title='commands', dest='command',
        help='See `%(prog)s <command> -h` for per-command usage info.')

    # install
    sub_parser = command_parser.add_parser(
        'install',
        help='Installs Bro packages.',
        description='Installs packages from a configured package source or'
                    ' directly from a git URL.  After installing, the package'
                    ' is marked as being "loaded" (see the "load" command).',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_install)
    sub_parser.add_argument(
        'package', nargs='+', help=pkg_name_help)
    sub_parser.add_argument(
        '--version', default=None,
        help='The version of the package to install.  Only one package may be'
        ' specified at a time when using this flag.  A version tag or branch'
        ' name may be specified here.  By default, the latest version tag is'
        ' installed, or if a package has no version tags, the "master"'
        ' branch is installed.')

    # remove
    sub_parser = command_parser.add_parser(
        'remove',
        help='Uninstall a package.',
        description='Unloads (see the "unload" command) and uninstalls a'
        ' previously installed package.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_remove)
    sub_parser.add_argument('package', nargs='+', help=pkg_name_help)

    # refresh
    sub_parser = command_parser.add_parser(
        'refresh',
        help='Retrieve updated package information.',
        description='Update local package source clones to retrieve information'
        ' about new packages that are available.  Also fetches updated package'
        ' information about any installed packages to determine if new versions'
        ' are available.  This does not upgrade installed packages (see the'
        ' "upgrade" command for that).',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_refresh)

    # upgrade
    sub_parser = command_parser.add_parser(
        'upgrade',
        help='Upgrade installed packages to latest versions.',
        description='Uprades the specified package(s) to latest available'
        ' version.  If no specific packages are specified, then all installed'
        ' packages that are outdated and not pinned are upgraded.  For packages'
        ' that are installed with `--version` using a git branch name, the'
        ' package is updated to the latest commit on that branch, else the'
        ' package is updated to the highest available git version tag.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_upgrade)
    sub_parser.add_argument(
        'package', nargs='*', default=[], help=pkg_name_help)

    # load
    sub_parser = command_parser.add_parser(
        'load',
        help='Register packages to be be auto-loaded by Bro.',
        description='The Bro Package Manager keeps track of all packages that'
        ' are marked as "loaded" and maintains a single Bro script that, when '
        ' loaded by Bro (e.g. via "@load packages"), will load all "loaded"'
        ' packages at once.'
        ' This command adds a set of packages to the "loaded packages" list.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_load)
    sub_parser.add_argument(
        'package', nargs='+', default=[],
        help='Name(s) of package(s) to load.')

    # unload
    sub_parser = command_parser.add_parser(
        'unload',
        help='Unregister packages to be be auto-loaded by Bro.',
        description='The Bro Package Manager keeps track of all packages that'
        ' are marked as "loaded" and maintains a single Bro script that, when '
        ' loaded by Bro, will load all "loaded" packages at once.'
        ' This command removes a set of packages from the "loaded packages"'
        ' list.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_unload)
    sub_parser.add_argument(
        'package', nargs='+', default=[], help=pkg_name_help)

    # pin
    sub_parser = command_parser.add_parser(
        'pin',
        help='Prevent packages from being automatically upgraded.',
        description='Pinned packages will be ignored by the "upgrade" command.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_pin)
    sub_parser.add_argument(
        'package', nargs='+', default=[], help=pkg_name_help)

    # unpin
    sub_parser = command_parser.add_parser(
        'unpin',
        help='Allows packages to be automatically upgraded.',
        description='Packages that are not pinned are automatically upgraded'
        ' by the "upgrade" command',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_unpin)
    sub_parser.add_argument(
        'package', nargs='+', default=[], help=pkg_name_help)

    # list
    sub_parser = command_parser.add_parser(
        'list',
        help='Lists packages.',
        description='Filters available/installed packages by a chosen category'
        ' and then outputs that filtered package list.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_list)
    sub_parser.add_argument('category', nargs='?', default='installed',
                            choices=['all', 'installed', 'not_installed',
                                     'loaded', 'unloaded', 'outdated'],
                            help='Package category used to filter listing.')

    # search
    sub_parser = command_parser.add_parser(
        'search',
        help='Search packages for matching names.',
        description='Perform a substring search on package names and metadata'
        ' tags.  Surround search text with slashes to indicate it is a regular'
        ' expression (e.g. "/text/").',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_search)
    sub_parser.add_argument(
        'search_text', help='The text/pattern to look for.')

    # info
    sub_parser = command_parser.add_parser(
        'info',
        help='Display package information.',
        description='Shows detailed information/metadata for given packages.'
        ' If the package is currently installed, additional information about'
        ' the status of it is displayed.  E.g. the installed version or whether'
        ' it is currently marked as "pinned" or "loaded."',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_info)
    sub_parser.add_argument(
        'package', nargs='+', default=[], help=pkg_name_help)

    # config
    sub_parser = command_parser.add_parser(
        'config',
        help='Show Bro Package Manager configuration info.',
        description='The default output of this command is a valid package'
        ' manager config file that corresponds to the one currently being used,'
        ' but also with any defaulted field values filled in.  This command'
        ' also allows for only the value of a specific field to be output if'
        ' the name of that field is given as an argument to the command.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_config)
    sub_parser.add_argument(
        'config_param', nargs='?', default='all',
        choices=['all', 'sources', 'statedir', 'scriptdir',
                 'plugindir', 'bro_exe', 'bro_dist'],
        help='Name of a specific config file field to output.')

    # env
    sub_parser = command_parser.add_parser(
        'env',
        help='Show the value of environment variables that need to be set for'
        ' Bro to be able to use installed packages.',
        description='This command returns shell commands that, when executed,'
        ' will correctly set BROPATH and BRO_PLUGIN_PATH to utilize the scripts'
        ' and plugins from packages installed by the package manager.  For this'
        ' command to function properly, either the "bro_exe" field of the config'
        ' file needs to be filled out, or the BROPATH and BRO_PLUGIN_PATH'
        ' environment variables should already contain valid paths to which'
        ' this command will append package-specific paths to.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    sub_parser.set_defaults(run_cmd=cmd_env)

    return top_parser


def main():
    args = argparser().parse_args()

    if args.verbose > 0:
        formatter = logging.Formatter(
            '%(asctime)s %(levelname)-8s %(message)s', '%Y-%m-%d %H:%M:%S')
        handler = logging.StreamHandler()
        handler.setFormatter(formatter)

        if args.verbose == 1:
            bropkg.LOG.setLevel(logging.WARNING)
        elif args.verbose == 2:
            bropkg.LOG.setLevel(logging.INFO)
        elif args.verbose == 3:
            bropkg.LOG.setLevel(logging.DEBUG)

        bropkg.LOG.addHandler(handler)

    manager, config = create_manager(args.configfile)

    args.run_cmd(manager, args, config)


if __name__ == '__main__':
    main()
    sys.exit(0)
